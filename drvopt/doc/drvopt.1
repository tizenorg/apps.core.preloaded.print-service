.mediasize a4
.nr PS 12500
.OF 'Samsung Research Center, Moscow'
.EF 'Samsung Research Center, Moscow'
.TL
Drvopt drv file optimizer


.DA
.AU
Ilyas Mankaev
.AI
Samsung Research Center
.AB
In this document briefly explained algorithm of drvopt utility. This utility optimizes drv
file with printer driver definitions.
.AE
.LL 7i
.NH
Preface
.PP
When i designed algorithm for drv file optimization, i kept in mind, that output
of drvopt optimizer will be used only by ppdc compiler. But optimized drv file
is turned more general and more flexible to use only by ppdc compiler. Really we
do not need to unpack all drivers that drv file contains. And i started getdrv 
utility design, which will provide this functionality.
.PP

.PP
Algorithm of optimization is very simple. At first i saw, that generated by ppdi
decompiler drv file have some structure:
.bp
.CDS
#include <media.h>
#include <fonts.h>

// Apollo 2000
{
...

  // Manufacturer and version
  Manufacturer "HP"
  Version 1.0

  // Each filter provided by the driver...
  Filter application/vnd.cups-raster 100 rastertofoo

  // Supported page sizes
  *MediaSize Letter
  MediaSize A4
  // all standard fonts...
  Font *
  ModelName "Apollo 2000"
  PCFileName "2000.ppd"

...
}

// Apollo 2100
{
...

  // Manufacturer and version
  Manufacturer "HP"
  Version 1.0

  // Each filter provided by the driver...
  Filter application/vnd.cups-raster 100 rastertofoo

  // Supported page sizes
  *MediaSize Letter
  MediaSize A4
  // all standard fonts...
  Font *
  ModelName "Apollo 2100"
  PCFileName "2100.ppd"

...
}
.CDE
.br
etc.
.bp
.PP
But in examples of drv file i already saw, that it is possible to group
some properties of printer, by this way:

.br
.CDS
#include <font.defs>
#include <media.defs>


// Manufacturer and version
Manufacturer "HP"
Version 1.0

// Each filter provided by the driver...
Filter application/vnd.cups-raster 100 rastertofoo

// Supported page sizes
*MediaSize Letter
MediaSize A4

{
  // Specify the model name and file name...
  ModelName "Apollo 2000"
  PCFileName "2000.ppd"
}

{
  // Specify the model name and file name...
  ModelName "Apollo 2100"
  PCFileName "2100.ppd"
}
.CDE

.PP
And it is clear, that there is simple tree structure behind us.
Because a section, that without curly braces - it is root node, which properties
inherits by models. And models is in curly braces.
.PP
Drvopt finds coincident attributes in models, then deletes its from both coincident models,
and places new node with this coincidences as parent of this nodes
.bp
.NH
Detailed explanation

.PP
To simplify understanding, i'll be using elements(models) with numerical attributes.

.PP
At first we have some initial set of elements.
.br
.PSPIC ./graph1.ps
.br

.PP
And root node of tree.
.br
.PSPIC ./graph2.ps
.br

.PP
Then we adding first element of tree.
.br
.PSPIC ./graph3.ps
.br

.PP
And whed we adding another elements to tree, we already applying our algorithm.
.br
.PSPIC ./graph4.ps
.br
.PP
Here we see, that general attributes of elements (7,9,8,4) and (8,9,5,2) will be new element (9,8),
and this new element will be parent node for them.

.PP
Adding (8,6) element.
.br
.PSPIC ./graph5.ps
.br
Element (8) will be new parent node for elements (6) and (9).
.br
.PP
And adding last element
.br
.PSPIC ./graph6.ps
.br

.NH
Conclusion

.PP
For rapid development, drvopt utility was written in Go language.
And i think we must not include its binary with distribution, because it
necessary only once, when generating drv file.
